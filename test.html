<html>
<head>
    <title>PTZ Camera Control</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- <link rel="icon" type="image/x-icon" href="static/favicon.ico">
    <link rel="stylesheet" href="static/style.css"> -->
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        
        h1 {
            color: #333;
            text-align: center;
        }
        
        #camera-container {
            max-width: 800px;
            margin: 0 auto;
            text-align: center;
        }
        
        #video {
            width: 100%;
            max-width: 640px;
            height: auto;
            border: 2px solid #333;
            border-radius: 8px;
        }
        
        #control-canvas {
            display: block;
            margin: 20px auto;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            outline: none;
        }
        
        #control-canvas:focus {
            border-color: #4CAF50;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }
        
        #instructions {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-top: 20px;
        }
        
        #instructions p {
            margin: 8px 0;
            color: #666;
        }
        
        #key-states {
            font-weight: bold;
            color: #4CAF50;
        }
    </style>
</head>
<body>
    <h1>PTZ Camera Control</h1>
    <div id="camera-container">
        <video id="video" autoplay playsinline controls></video>
        <canvas id="control-canvas" width="400" height="300" tabindex="0" 
                style="border: 2px solid #333; margin-top: 10px; cursor: crosshair;">
        </canvas>
        <div id="instructions">
            <p>Click on the canvas to focus, then use arrow keys to control the camera</p>
            <p>Key states: <span id="key-states">None</span></p>
        </div>
    </div></video>

    <script>
        async function startWebRTC() {
        const pc = new RTCPeerConnection();

        // Attach remote tracks to video
        const videoEl = document.getElementById("video");
        pc.ontrack = (event) => {
            videoEl.srcObject = event.streams[0];
        };

        // We are only receiving (no local mic/cam)
        pc.addTransceiver("audio", { direction: "recvonly" });
        pc.addTransceiver("video", { direction: "recvonly" });

        // Create offer
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        // Send SDP offer to camera
        const resp = await fetch("http://10.10.1.75:30080/index/api/webrtc?app=live&stream=stream1&type=play", {
            method: "POST",
            headers: { "Content-Type": "application/sdp" },
            body: offer.sdp
        });

        const answer = await resp.json();

        // Apply SDP answer from camera
        await pc.setRemoteDescription({
            type: "answer",
            sdp: answer.sdp
        });
        }

        startWebRTC();

        // Canvas-based key handling system
        const canvas = document.getElementById("control-canvas");
        const ctx = canvas.getContext("2d");
        const keyStatesDisplay = document.getElementById("key-states");
        const camera_ip = "10.10.1.75";

        // Key state tracking
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            Shift: false,
            Control: false
        };

        let lastCommand = null;
        let commandCooldown = 0;
        const COMMAND_DELAY = 100; // milliseconds between commands

        // Focus canvas on click
        canvas.addEventListener("click", () => {
            canvas.focus();
        });

        // Key event listeners for the canvas
        canvas.addEventListener("keydown", (event) => {
            if (keys.hasOwnProperty(event.key)) {
                event.preventDefault();
                keys[event.key] = true;
            }
        });

        canvas.addEventListener("keyup", (event) => {
            if (keys.hasOwnProperty(event.key)) {
                event.preventDefault();
                keys[event.key] = false;
            }
        });

        // Prevent canvas from losing focus
        canvas.addEventListener("blur", () => {
            // Reset all keys when focus is lost
            Object.keys(keys).forEach(key => keys[key] = false);
        });

        // Send PTZ command
        function sendPTZCommand(action, x = 0, y = undefined) {
            const command = `${action}_${x}${y !== undefined ? `_${y}` : ''}`;
            if (action.startsWith("zoom")) {
                y = undefined; // Zoom commands only uses x parameter
            }
            if (command !== lastCommand) {
                const url = `http://${camera_ip}/cgi-bin/ptzctrl.cgi?ptzcmd&${action}&${x}${y !== undefined ? `&${y}` : ''}`;
                fetch(url).catch(err => console.error("PTZ command failed:", err));
                lastCommand = command;
                console.log(`PTZ Command: ${action} (${x}, ${y})`);
                console.log("Sent URL:", url);
            }
        }

        // Draw control interface on canvas
        function drawControls() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background
            ctx.fillStyle = "#f0f0f0";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Grid lines
            ctx.strokeStyle = "#ddd";
            ctx.lineWidth = 1;
            for (let i = 0; i <= canvas.width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= canvas.height; i += 50) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }
            
            // Center crosshair
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            ctx.strokeStyle = "#666";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX - 20, centerY);
            ctx.lineTo(centerX + 20, centerY);
            ctx.moveTo(centerX, centerY - 20);
            ctx.lineTo(centerX, centerY + 20);
            ctx.stroke();
            
            // Direction indicators
            ctx.fillStyle = "#333";
            ctx.font = "16px Arial";
            ctx.textAlign = "center";
            
            // Show active directions
            if (keys.ArrowUp) {
                ctx.fillStyle = "#4CAF50";
                ctx.fillRect(centerX - 30, centerY - 60, 60, 20);
                ctx.fillStyle = "white";
                ctx.fillText("UP", centerX, centerY - 45);
            } else {
                ctx.fillStyle = "#333";
                ctx.fillText("↑", centerX, centerY - 45);
            }
            
            if (keys.ArrowDown) {
                ctx.fillStyle = "#4CAF50";
                ctx.fillRect(centerX - 30, centerY + 40, 60, 20);
                ctx.fillStyle = "white";
                ctx.fillText("DOWN", centerX, centerY + 55);
            } else {
                ctx.fillStyle = "#333";
                ctx.fillText("↓", centerX, centerY + 55);
            }
            
            if (keys.ArrowLeft) {
                ctx.fillStyle = "#4CAF50";
                ctx.fillRect(centerX - 80, centerY - 10, 40, 20);
                ctx.fillStyle = "white";
                ctx.fillText("LEFT", centerX - 60, centerY + 5);
            } else {
                ctx.fillStyle = "#333";
                ctx.fillText("←", centerX - 60, centerY + 5);
            }
            
            if (keys.ArrowRight) {
                ctx.fillStyle = "#4CAF50";
                ctx.fillRect(centerX + 40, centerY - 10, 40, 20);
                ctx.fillStyle = "white";
                ctx.fillText("RIGHT", centerX + 60, centerY + 5);
            } else {
                ctx.fillStyle = "#333";
                ctx.fillText("→", centerX + 60, centerY + 5);
            }

            // Zoom indicators
            ctx.font = "14px Arial";
            if (keys.Shift) {
                ctx.fillStyle = "#2196F3";
                ctx.fillRect(centerX - 40, centerY + 80, 80, 18);
                ctx.fillStyle = "white";
                ctx.fillText("ZOOM IN", centerX, centerY + 93);
            } else {
                ctx.fillStyle = "#666";
                ctx.fillText("SHIFT: Zoom In", centerX, centerY + 85);
            }
            
            if (keys.Control) {
                ctx.fillStyle = "#FF9800";
                ctx.fillRect(centerX - 40, centerY + 105, 80, 18);
                ctx.fillStyle = "white";
                ctx.fillText("ZOOM OUT", centerX, centerY + 118);
            } else {
                ctx.fillStyle = "#666";
                ctx.fillText("CTRL: Zoom Out", centerX, centerY + 110);
            }
        }

        // Main game loop
        function gameLoop(timestamp) {
            // Update key states display
            const activeKeys = Object.keys(keys).filter(key => keys[key]);
            keyStatesDisplay.textContent = activeKeys.length > 0 ? activeKeys.join(", ") : "None";
            
            // Handle PTZ commands with cooldown
            if (commandCooldown <= 0) {
                const isAnyKeyPressed = Object.values(keys).some(pressed => pressed);
                
                if (isAnyKeyPressed) {
                    // Determine action based on pressed keys
                    let action = null;
                    let x = 0, y = 0;
                    
                    if (keys.ArrowUp && keys.ArrowLeft) {
                        action = "upleft"; x = 1; y = 1;
                    } else if (keys.ArrowUp && keys.ArrowRight) {
                        action = "upright"; x = 1; y = 1;
                    } else if (keys.ArrowDown && keys.ArrowLeft) {
                        action = "downleft"; x = 1; y = 1;
                    } else if (keys.ArrowDown && keys.ArrowRight) {
                        action = "downright"; x = 1; y = 1;
                    } else if (keys.ArrowUp) {
                        action = "up"; y = 1;
                    } else if (keys.ArrowDown) {
                        action = "down"; y = 1;
                    } else if (keys.ArrowLeft) {
                        action = "left"; x = 1;
                    } else if (keys.ArrowRight) {
                        action = "right"; x = 1;
                    } else if (keys.Shift) {
                        action = "zoomin"; x = 2;
                    } else if (keys.Control) {
                        action = "zoomout"; x = 2;
                    }
                    
                    if (action) {
                        sendPTZCommand(action, x, y);
                        commandCooldown = COMMAND_DELAY;
                    }
                } else if (lastCommand && lastCommand !== "stop") {
                    // Send stop command when no keys are pressed
                    sendPTZCommand("ptzstop", 0, 0);
                    // sendPTZCommand("zoomstop", 0);
                    lastCommand = "stop";
                    commandCooldown = COMMAND_DELAY;
                }
            } else {
                commandCooldown -= 16; // Approximate frame time
            }
            
            // Draw the control interface
            drawControls();
            
            // Continue the loop
            requestAnimationFrame(gameLoop);
        }

        // Start the game loop
        requestAnimationFrame(gameLoop);

        // Initial canvas focus
        canvas.focus();
    </script>
</body>
</html>